1. SQLiteè¿æ¥DSNä¼˜åŒ–
åŒæ„ï¼šä½¿ç”¨ ?_journal_mode=WAL&_busy_timeout=5000
func InitSQLite(dbPath string) (*sql.DB, error) {
    // ä½¿ç”¨æ­£ç¡®çš„busy_timeoutå‚æ•°
    dsn := dbPath + "?_journal_mode=WAL&_busy_timeout=5000&_foreign_keys=on"
    db, err := sql.Open("sqlite3", dsn)
    if err != nil {
        return nil, err
    }
    
    // éªŒè¯WALæ¨¡å¼å·²å¯ç”¨
    var journalMode string
    err = db.QueryRow("PRAGMA journal_mode").Scan(&journalMode)
    if err != nil {
        return nil, err
    }
    log.Printf("SQLite journal mode: %s", journalMode)
    
    return db, nil
}

2. updated_atè§¦å‘å™¨ä¼˜åŒ–
åŒæ„ï¼šæ”¹ä¸ºBEFORE UPDATEè§¦å‘å™¨
-- migrations/001_initial.sql
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp 
BEFORE UPDATE ON servers
FOR EACH ROW
BEGIN
    SET NEW.updated_at = CURRENT_TIMESTAMP;
END;


3. APIå­—æ®µå‘½åç­–ç•¥
åŒæ„ï¼šAPIä½¿ç”¨camelCaseï¼ŒDBä½¿ç”¨snake_case
// models.go - æ˜ç¡®çš„å­—æ®µæ˜ å°„
type ConfigTemplate struct {
    ID            int    `json:"id" db:"id"`
    Name          string `json:"name" db:"name"`
    Description   string `json:"description" db:"description"`
    SystemType    string `json:"systemType" db:"system_type"`
    SystemVersion string `json:"systemVersion" db:"system_version"`
    ConfigContent string `json:"configContent" db:"config_content"` // API: configContent, DB: config_content
    KernelParams  string `json:"kernelParams" db:"kernel_params"`
    Packages      string `json:"packages" db:"packages"`
    Status        string `json:"status" db:"status"`
    CreatedAt     string `json:"createdAt" db:"created_at"`
}

// APIè¯·æ±‚ä½“
type CreateConfigRequest struct {
    Name          string `json:"name" binding:"required"`
    Description   string `json:"description"`
    SystemType    string `json:"systemType" binding:"required"`
    SystemVersion string `json:"systemVersion"`
    ConfigContent string `json:"configContent" binding:"required"`
    KernelParams  string `json:"kernelParams"`
    Packages      string `json:"packages"`
}

4. ç™½åå•ä¼˜å…ˆçº§ç­–ç•¥
åŒæ„ï¼šå®‰å…¨å±‚ç™½åå•å…ˆè¡Œæ”¾è¡Œï¼Œé™æµå±‚ä»…å¯¹éç™½åå•ç”Ÿæ•ˆ
// auth/middleware.go - ç»Ÿä¸€ç™½åå•é…ç½®
type SecurityConfig struct {
    AuthToken    string   `json:"-"`
    WhitelistIPs []string `json:"whitelistIPs"` // ç»Ÿä¸€ç™½åå•é…ç½®
    EnableAudit  bool     `json:"enableAudit"`
    AuditLogPath string   `json:"auditLogPath"`
}

// è®¤è¯ä¸­é—´ä»¶ - å…ˆæ£€æŸ¥ç™½åå•
func Middleware(securityConfig *SecurityConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // ç™½åå•IPç›´æ¥æ”¾è¡Œï¼ˆä¸æ£€æŸ¥Tokenï¼‰
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        // éç™½åå•IPéœ€è¦Tokenè®¤è¯
        token := c.GetHeader("Authorization")
        if !strings.HasPrefix(token, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æœªæä¾›è®¤è¯ä»¤ç‰Œ"})
            c.Abort()
            return
        }
        
        if strings.TrimPrefix(token, "Bearer ") != securityConfig.AuthToken {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶ - ä»…å¯¹éç™½åå•IPç”Ÿæ•ˆ
func RateLimitMiddleware(securityConfig *SecurityConfig, requestsPerMinute int) gin.HandlerFunc {
    limiter := rate.NewLimiter(rate.Every(time.Minute/time.Duration(requestsPerMinute)), requestsPerMinute)
    
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // ç™½åå•IPä¸é™æµ
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{"error": "è¯·æ±‚è¿‡äºé¢‘ç¹"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}



ğŸ¯ é£é™©ç¼“è§£ä¼˜åŒ–
1. UEFIå¼•å¯¼äº§ç‰©æ ‡å‡†åŒ–
type PXEConfig struct {
    EnableUEFI      bool   `json:"enableUEFI"`
    UEFIBootPath    string `json:"uefiBootPath"`    // é»˜è®¤: "efi/boot/"
    LegacyBootPath  string `json:"legacyBootPath"`  // é»˜è®¤: "pxelinux.cfg/"
    UEFIBootFile    string `json:"uefiBootFile"`    // é»˜è®¤: "grubx64.efi"
    UEFIConfigFile  string `json:"uefiConfigFile"`  // é»˜è®¤: "grub.cfg"
    LegacyBootFile  string `json:"legacyBootFile"`  // é»˜è®¤: "pxelinux.0"
}

func DefaultPXEConfig() *PXEConfig {
    return &PXEConfig{
        EnableUEFI:      false,
        UEFIBootPath:    "efi/boot/",
        LegacyBootPath:  "pxelinux.cfg/",
        UEFIBootFile:    "grubx64.efi",
        UEFIConfigFile:  "grub.cfg",
        LegacyBootFile:  "pxelinux.0",
    }
}

2. å®¡è®¡æ—¥å¿—æ ‡å‡†åŒ–
type AuditLog struct {
    Timestamp  string                 `json:"timestamp"`
    ClientIP   string                 `json:"clientIP"`
    UserAgent  string                 `json:"userAgent"`
    Method     string                 `json:"method"`
    Path       string                 `json:"path"`
    Action     string                 `json:"action"`     // æ“ä½œç±»å‹: report, confirm, apply, etc.
    Target     string                 `json:"target"`     // ç›®æ ‡: serialæˆ–config ID
    Status     string                 `json:"status"`     // ç»“æœ: success, failure
    Error      string                 `json:"error,omitempty"`
    Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

func LogAuditEvent(c *gin.Context, action, target, status string, err error) {
    auditLog := AuditLog{
        Timestamp: time.Now().Format(time.RFC3339),
        ClientIP:  c.ClientIP(),
        UserAgent: c.GetHeader("User-Agent"),
        Method:    c.Request.Method,
        Path:      c.Request.URL.Path,
        Action:    action,
        Target:    target,
        Status:    status,
    }
    
    if err != nil {
        auditLog.Error = err.Error()
    }
    
    // è¾“å‡ºJSONè¡Œæ ¼å¼
    logJSON, _ := json.Marshal(auditLog)
    fmt.Println(string(logJSON)) // å¯é‡å®šå‘åˆ°æ–‡ä»¶
}

3. Agentæƒé™é™çº§ä¸å…¼å®¹æ€§
#!/bin/bash

# å¢å¼ºçš„Agenté‡‡é›†è„šæœ¬
collect_system_info() {
    # æƒé™æ£€æµ‹ä¸é™çº§
    if [ "$EUID" -ne 0 ]; then
        echo "è­¦å‘Š: érootç”¨æˆ·è¿è¡Œï¼Œéƒ¨åˆ†ä¿¡æ¯å¯èƒ½æ— æ³•é‡‡é›†" >&2
        CAN_USE_DMIDECODE=false
    else
        CAN_USE_DMIDECODE=true
    fi
    
    # ç½‘å¡è‡ªé€‚åº”æ¢æµ‹
    detect_network_interfaces() {
        # æ–¹æ³•1: é€šè¿‡é»˜è®¤è·¯ç”±æ£€æµ‹ä¸»ç½‘å¡
        PRIMARY_IFACE=$(ip route show default 2>/dev/null | awk '/default/ {print $5}' | head -1)
        
        # æ–¹æ³•2: éå†/sys/class/net
        if [ -z "$PRIMARY_IFACE" ]; then
            for iface in /sys/class/net/*; do
                iface_name=$(basename "$iface")
                # æ’é™¤loå’Œè™šæ‹Ÿæ¥å£
                if [ "$iface_name" != "lo" ] && [[ ! "$iface_name" =~ ^veth ]]; then
                    PRIMARY_IFACE=$iface_name
                    break
                fi
            done
        fi
        
        echo "$PRIMARY_IFACE"
    }
    
    PRIMARY_NIC=$(detect_network_interfaces)
    
    # åºåˆ—å·é‡‡é›†ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
    if [ "$CAN_USE_DMIDECODE" = true ] && command -v dmidecode >/dev/null; then
        SERIAL=$(dmidecode -s system-serial-number 2>/dev/null | head -1)
    else
        # é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æœºå™¨IDæˆ–ä¸»æœºå
        if [ -f /etc/machine-id ]; then
            SERIAL=$(cat /etc/machine-id | cut -c1-12)
        else
            SERIAL=$(hostname)-$(date +%s)
        fi
    fi
    
    # ç”Ÿæˆå”¯ä¸€è¯·æ±‚ID
    REQUEST_ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || date +%s%N | md5sum | cut -d' ' -f1)
    
    # ç»„è£…JSONæ•°æ®ï¼ˆä½¿ç”¨å°é©¼å³°å­—æ®µåï¼‰
    JSON_DATA=$(cat <<EOF
{
    "requestId": "$REQUEST_ID",
    "serial": "$SERIAL",
    "hostname": "$(hostname)",
    "ipAddress": "$(ip route get 1 2>/dev/null | awk '{print $7}' | head -1)",
    "macAddress": "$(cat /sys/class/net/$PRIMARY_NIC/address 2>/dev/null)",
    "primaryNic": "$PRIMARY_NIC",
    "gateway": "$(ip route show default 2>/dev/null | awk '/default/ {print $3}')",
    "installTime": "$(date '+%Y-%m-%d %H:%M:%S')",
    "sdaSize": "$(lsblk -b /dev/sda 2>/dev/null | awk 'NR==2 {print $4}' || echo "unknown")",
    "part": "$(lsblk -o NAME,SIZE,MOUNTPOINT /dev/sda 2>/dev/null | grep -v NAME | tr '\n' ',' | head -c 200)",
    "systemVersion": "$(detect_os_version)",
    "kernelVersion": "$(uname -r)",
    "cpuModel": "$(grep "model name" /proc/cpuinfo 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^ *//' || echo "unknown")",
    "cpuProcessor": $(grep -c "^processor" /proc/cpuinfo 2>/dev/null || echo 1),
    "memTotal": $(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || echo 0),
    "memoryNum": $(detect_memory_slots),
    "lanNic": "$PRIMARY_NIC",
    "lanNicSpeed": "$(detect_nic_speed "$PRIMARY_NIC")"
}
EOF
)
    
    # å‘é€æ•°æ®ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
    send_with_retry "$JSON_DATA"
}

4. è¯·æ±‚å¹‚ç­‰æ€§ä¿éšœ
// æœåŠ¡ç«¯è¯·æ±‚å»é‡
type ServerReportRequest struct {
    RequestID string `json:"requestId" binding:"required"` // å”¯ä¸€è¯·æ±‚ID
    Serial    string `json:"serial" binding:"required"`
    // ... å…¶ä»–å­—æ®µ
}

func ReportHandler(db *database.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req ServerReportRequest
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "æ— æ•ˆçš„è¯·æ±‚æ•°æ®", http.StatusBadRequest)
            return
        }
        
        // æ£€æŸ¥è¯·æ±‚æ˜¯å¦å·²å¤„ç†ï¼ˆåŸºäºserial + requestIdï¼‰
        if isDuplicateRequest(db, req.Serial, req.RequestID) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(map[string]string{
                "status":  "success", 
                "message": "é‡å¤è¯·æ±‚ï¼Œå·²å¿½ç•¥",
            })
            return
        }
        
        // å¤„ç†è¯·æ±‚å¹¶è®°å½•requestId
        if err := processServerReport(db, &req); err != nil {
            http.Error(w, "å¤„ç†è¯·æ±‚å¤±è´¥", http.StatusInternalServerError)
            return
        }
        
        // è®°å½•å·²å¤„ç†çš„è¯·æ±‚ID
        recordRequestID(db, req.Serial, req.RequestID)
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "status":  "success",
            "message": "æœåŠ¡å™¨ä¿¡æ¯å·²æ¥æ”¶ï¼Œç­‰å¾…ç®¡ç†å‘˜ç¡®è®¤",
        })
    }
}

ğŸš€ å®æ–½è®¡åˆ’æ›´æ–°
ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¾æ–½ï¼ˆç«‹å³å¼€å§‹ï¼‰
æ•°æ®åº“ä¸è¿ç§»

åˆ›å»º migrations/001_initial.sqlï¼ˆå«ä¼˜åŒ–åçš„è§¦å‘å™¨ï¼‰

å®ç° database/db.goï¼ˆå«SQLite WALå’Œbusy_timeoutï¼‰

åˆ›å»º database/models.goï¼ˆç»Ÿä¸€å­—æ®µæ˜ å°„ï¼‰

è®¤è¯ä¸å®‰å…¨

åˆ›å»º auth/middleware.goï¼ˆç»Ÿä¸€ç™½åå•ç­–ç•¥ï¼‰

åˆ›å»º auth/ratelimit.goï¼ˆéç™½åå•é™æµï¼‰

åˆ›å»º config/config.goï¼ˆå®‰å…¨é…ç½®ç»“æ„ï¼‰

ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒæœåŠ¡ï¼ˆä¸‹å‘¨ï¼‰
PXEç”Ÿæˆå¼•æ“

åˆ›å»º pxe/generator.goï¼ˆUEFI/Legacyæ”¯æŒï¼‰

åˆ›å»º pxe/kickstart.goï¼ˆCentOSæ¨¡æ¿ï¼‰

åˆ›å»º pxe/preseed.goï¼ˆUbuntuæ¨¡æ¿ï¼‰

APIè·¯ç”±å®Œå–„

åˆ›å»º api/handlers.goï¼ˆæ‰€æœ‰è·¯ç”±å¤„ç†å™¨ï¼‰

åˆ›å»º api/router.goï¼ˆå®Œæ•´è·¯ç”±è®¾ç½®ï¼‰

å®ç°å®¡è®¡æ—¥å¿—ä¸­é—´ä»¶

ç¬¬ä¸‰é˜¶æ®µï¼šå‰ç«¯ä¸Agentï¼ˆä¸‹ä¸‹å‘¨ï¼‰
Webå‰ç«¯

å®Œå–„ web/static/js/app.jsï¼ˆå®Œæ•´äº¤äº’ï¼‰

åˆ›å»ºé”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€ç»„ä»¶

Agentå¢å¼º

æ›´æ–°Agentè„šæœ¬ï¼ˆæƒé™é™çº§+ç½‘å¡è‡ªé€‚åº”ï¼‰

å®ç°é‡è¯•æœºåˆ¶å’Œè¯·æ±‚å¹‚ç­‰

ğŸ“‹ ç«‹å³æ‰§è¡Œé¡¹ç›®
åŸºäºæ‚¨çš„ç¡®è®¤ï¼Œæˆ‘å°†ç«‹å³å¼€å§‹å®æ–½ä»¥ä¸‹å†…å®¹ï¼š

åˆ›å»ºæ•°æ®åº“è¿ç§»è„šæœ¬ï¼ˆå«ä¼˜åŒ–è§¦å‘å™¨ï¼‰

å®ç°æ•°æ®åº“è¿æ¥å±‚ï¼ˆSQLite WAL + busy_timeoutï¼‰

å®šä¹‰ç»Ÿä¸€æ•°æ®æ¨¡å‹ï¼ˆcamelCase API + snake_case DBï¼‰

åˆ›å»ºè®¤è¯ä¸­é—´ä»¶ï¼ˆç»Ÿä¸€ç™½åå•ç­–ç•¥ï¼‰


