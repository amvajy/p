1. SQLite连接DSN优化
同意：使用 ?_journal_mode=WAL&_busy_timeout=5000
func InitSQLite(dbPath string) (*sql.DB, error) {
    // 使用正确的busy_timeout参数
    dsn := dbPath + "?_journal_mode=WAL&_busy_timeout=5000&_foreign_keys=on"
    db, err := sql.Open("sqlite3", dsn)
    if err != nil {
        return nil, err
    }
    
    // 验证WAL模式已启用
    var journalMode string
    err = db.QueryRow("PRAGMA journal_mode").Scan(&journalMode)
    if err != nil {
        return nil, err
    }
    log.Printf("SQLite journal mode: %s", journalMode)
    
    return db, nil
}

2. updated_at触发器优化
同意：改为BEFORE UPDATE触发器
-- migrations/001_initial.sql
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp 
BEFORE UPDATE ON servers
FOR EACH ROW
BEGIN
    SET NEW.updated_at = CURRENT_TIMESTAMP;
END;


3. API字段命名策略
同意：API使用camelCase，DB使用snake_case
// models.go - 明确的字段映射
type ConfigTemplate struct {
    ID            int    `json:"id" db:"id"`
    Name          string `json:"name" db:"name"`
    Description   string `json:"description" db:"description"`
    SystemType    string `json:"systemType" db:"system_type"`
    SystemVersion string `json:"systemVersion" db:"system_version"`
    ConfigContent string `json:"configContent" db:"config_content"` // API: configContent, DB: config_content
    KernelParams  string `json:"kernelParams" db:"kernel_params"`
    Packages      string `json:"packages" db:"packages"`
    Status        string `json:"status" db:"status"`
    CreatedAt     string `json:"createdAt" db:"created_at"`
}

// API请求体
type CreateConfigRequest struct {
    Name          string `json:"name" binding:"required"`
    Description   string `json:"description"`
    SystemType    string `json:"systemType" binding:"required"`
    SystemVersion string `json:"systemVersion"`
    ConfigContent string `json:"configContent" binding:"required"`
    KernelParams  string `json:"kernelParams"`
    Packages      string `json:"packages"`
}

4. 白名单优先级策略
同意：安全层白名单先行放行，限流层仅对非白名单生效
// auth/middleware.go - 统一白名单配置
type SecurityConfig struct {
    AuthToken    string   `json:"-"`
    WhitelistIPs []string `json:"whitelistIPs"` // 统一白名单配置
    EnableAudit  bool     `json:"enableAudit"`
    AuditLogPath string   `json:"auditLogPath"`
}

// 认证中间件 - 先检查白名单
func Middleware(securityConfig *SecurityConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // 白名单IP直接放行（不检查Token）
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        // 非白名单IP需要Token认证
        token := c.GetHeader("Authorization")
        if !strings.HasPrefix(token, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "未提供认证令牌"})
            c.Abort()
            return
        }
        
        if strings.TrimPrefix(token, "Bearer ") != securityConfig.AuthToken {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的认证令牌"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 速率限制中间件 - 仅对非白名单IP生效
func RateLimitMiddleware(securityConfig *SecurityConfig, requestsPerMinute int) gin.HandlerFunc {
    limiter := rate.NewLimiter(rate.Every(time.Minute/time.Duration(requestsPerMinute)), requestsPerMinute)
    
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // 白名单IP不限流
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{"error": "请求过于频繁"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}



🎯 风险缓解优化
1. UEFI引导产物标准化
type PXEConfig struct {
    EnableUEFI      bool   `json:"enableUEFI"`
    UEFIBootPath    string `json:"uefiBootPath"`    // 默认: "efi/boot/"
    LegacyBootPath  string `json:"legacyBootPath"`  // 默认: "pxelinux.cfg/"
    UEFIBootFile    string `json:"uefiBootFile"`    // 默认: "grubx64.efi"
    UEFIConfigFile  string `json:"uefiConfigFile"`  // 默认: "grub.cfg"
    LegacyBootFile  string `json:"legacyBootFile"`  // 默认: "pxelinux.0"
}

func DefaultPXEConfig() *PXEConfig {
    return &PXEConfig{
        EnableUEFI:      false,
        UEFIBootPath:    "efi/boot/",
        LegacyBootPath:  "pxelinux.cfg/",
        UEFIBootFile:    "grubx64.efi",
        UEFIConfigFile:  "grub.cfg",
        LegacyBootFile:  "pxelinux.0",
    }
}

2. 审计日志标准化
type AuditLog struct {
    Timestamp  string                 `json:"timestamp"`
    ClientIP   string                 `json:"clientIP"`
    UserAgent  string                 `json:"userAgent"`
    Method     string                 `json:"method"`
    Path       string                 `json:"path"`
    Action     string                 `json:"action"`     // 操作类型: report, confirm, apply, etc.
    Target     string                 `json:"target"`     // 目标: serial或config ID
    Status     string                 `json:"status"`     // 结果: success, failure
    Error      string                 `json:"error,omitempty"`
    Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

func LogAuditEvent(c *gin.Context, action, target, status string, err error) {
    auditLog := AuditLog{
        Timestamp: time.Now().Format(time.RFC3339),
        ClientIP:  c.ClientIP(),
        UserAgent: c.GetHeader("User-Agent"),
        Method:    c.Request.Method,
        Path:      c.Request.URL.Path,
        Action:    action,
        Target:    target,
        Status:    status,
    }
    
    if err != nil {
        auditLog.Error = err.Error()
    }
    
    // 输出JSON行格式
    logJSON, _ := json.Marshal(auditLog)
    fmt.Println(string(logJSON)) // 可重定向到文件
}

3. Agent权限降级与兼容性
#!/bin/bash

# 增强的Agent采集脚本
collect_system_info() {
    # 权限检测与降级
    if [ "$EUID" -ne 0 ]; then
        echo "警告: 非root用户运行，部分信息可能无法采集" >&2
        CAN_USE_DMIDECODE=false
    else
        CAN_USE_DMIDECODE=true
    fi
    
    # 网卡自适应探测
    detect_network_interfaces() {
        # 方法1: 通过默认路由检测主网卡
        PRIMARY_IFACE=$(ip route show default 2>/dev/null | awk '/default/ {print $5}' | head -1)
        
        # 方法2: 遍历/sys/class/net
        if [ -z "$PRIMARY_IFACE" ]; then
            for iface in /sys/class/net/*; do
                iface_name=$(basename "$iface")
                # 排除lo和虚拟接口
                if [ "$iface_name" != "lo" ] && [[ ! "$iface_name" =~ ^veth ]]; then
                    PRIMARY_IFACE=$iface_name
                    break
                fi
            done
        fi
        
        echo "$PRIMARY_IFACE"
    }
    
    PRIMARY_NIC=$(detect_network_interfaces)
    
    # 序列号采集（降级方案）
    if [ "$CAN_USE_DMIDECODE" = true ] && command -v dmidecode >/dev/null; then
        SERIAL=$(dmidecode -s system-serial-number 2>/dev/null | head -1)
    else
        # 降级方案：使用机器ID或主机名
        if [ -f /etc/machine-id ]; then
            SERIAL=$(cat /etc/machine-id | cut -c1-12)
        else
            SERIAL=$(hostname)-$(date +%s)
        fi
    fi
    
    # 生成唯一请求ID
    REQUEST_ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || date +%s%N | md5sum | cut -d' ' -f1)
    
    # 组装JSON数据（使用小驼峰字段名）
    JSON_DATA=$(cat <<EOF
{
    "requestId": "$REQUEST_ID",
    "serial": "$SERIAL",
    "hostname": "$(hostname)",
    "ipAddress": "$(ip route get 1 2>/dev/null | awk '{print $7}' | head -1)",
    "macAddress": "$(cat /sys/class/net/$PRIMARY_NIC/address 2>/dev/null)",
    "primaryNic": "$PRIMARY_NIC",
    "gateway": "$(ip route show default 2>/dev/null | awk '/default/ {print $3}')",
    "installTime": "$(date '+%Y-%m-%d %H:%M:%S')",
    "sdaSize": "$(lsblk -b /dev/sda 2>/dev/null | awk 'NR==2 {print $4}' || echo "unknown")",
    "part": "$(lsblk -o NAME,SIZE,MOUNTPOINT /dev/sda 2>/dev/null | grep -v NAME | tr '\n' ',' | head -c 200)",
    "systemVersion": "$(detect_os_version)",
    "kernelVersion": "$(uname -r)",
    "cpuModel": "$(grep "model name" /proc/cpuinfo 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^ *//' || echo "unknown")",
    "cpuProcessor": $(grep -c "^processor" /proc/cpuinfo 2>/dev/null || echo 1),
    "memTotal": $(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || echo 0),
    "memoryNum": $(detect_memory_slots),
    "lanNic": "$PRIMARY_NIC",
    "lanNicSpeed": "$(detect_nic_speed "$PRIMARY_NIC")"
}
EOF
)
    
    # 发送数据（带重试机制）
    send_with_retry "$JSON_DATA"
}

4. 请求幂等性保障
// 服务端请求去重
type ServerReportRequest struct {
    RequestID string `json:"requestId" binding:"required"` // 唯一请求ID
    Serial    string `json:"serial" binding:"required"`
    // ... 其他字段
}

func ReportHandler(db *database.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req ServerReportRequest
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "无效的请求数据", http.StatusBadRequest)
            return
        }
        
        // 检查请求是否已处理（基于serial + requestId）
        if isDuplicateRequest(db, req.Serial, req.RequestID) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(map[string]string{
                "status":  "success", 
                "message": "重复请求，已忽略",
            })
            return
        }
        
        // 处理请求并记录requestId
        if err := processServerReport(db, &req); err != nil {
            http.Error(w, "处理请求失败", http.StatusInternalServerError)
            return
        }
        
        // 记录已处理的请求ID
        recordRequestID(db, req.Serial, req.RequestID)
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "status":  "success",
            "message": "服务器信息已接收，等待管理员确认",
        })
    }
}

🚀 实施计划更新
第一阶段：基础设施（立即开始）
数据库与迁移

创建 migrations/001_initial.sql（含优化后的触发器）

实现 database/db.go（含SQLite WAL和busy_timeout）

创建 database/models.go（统一字段映射）

认证与安全

创建 auth/middleware.go（统一白名单策略）

创建 auth/ratelimit.go（非白名单限流）

创建 config/config.go（安全配置结构）

第二阶段：核心服务（下周）
PXE生成引擎

创建 pxe/generator.go（UEFI/Legacy支持）

创建 pxe/kickstart.go（CentOS模板）

创建 pxe/preseed.go（Ubuntu模板）

API路由完善

创建 api/handlers.go（所有路由处理器）

创建 api/router.go（完整路由设置）

实现审计日志中间件

第三阶段：前端与Agent（下下周）
Web前端

完善 web/static/js/app.js（完整交互）

创建错误处理和加载状态组件

Agent增强

更新Agent脚本（权限降级+网卡自适应）

实现重试机制和请求幂等

📋 立即执行项目
基于您的确认，我将立即开始实施以下内容：

创建数据库迁移脚本（含优化触发器）

实现数据库连接层（SQLite WAL + busy_timeout）

定义统一数据模型（camelCase API + snake_case DB）

创建认证中间件（统一白名单策略）


