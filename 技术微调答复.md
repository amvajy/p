âœ… æŠ€æœ¯å¾®è°ƒç¡®è®¤
1. SQLiteè§¦å‘å™¨è¯­æ³•ä¿®æ­£
åŒæ„ï¼šä½¿ç”¨åˆ—é›†é™å®šçš„AFTER UPDATEè§¦å‘å™¨
-- migrations/001_initial.sql
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp
AFTER UPDATE OF serial, hostname, ip_address, mac_address, gateway, install_time, 
                  sda_size, part, system_version, kernel_version, cpu_model, 
                  cpu_processor, mem_total, memory_num, lan_nic, lan_nic_speed, 
                  wan_nic, wan_nic_speed, bond_nic, bond_nic_speed, status 
ON servers
FOR EACH ROW
BEGIN
    UPDATE servers SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;



2. é™æµå™¨ç»´åº¦ä¼˜åŒ–
åŒæ„ï¼šæŒ‰IPç»´åº¦ç»´æŠ¤ç‹¬ç«‹é™æµå™¨ï¼Œä½¿ç”¨å¸¦TTLçš„æœ¬åœ°ç¼“å­˜
// auth/ratelimit.go
package auth

import (
    "net/http"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
    "github.com/gin-gonic/gin"
)

type IPRateLimiter struct {
    ips map[string]*rate.Limiter
    mu   *sync.RWMutex
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
    return &IPRateLimiter{
        ips: make(map[string]*rate.Limiter),
        mu:   &sync.RWMutex{},
    }
}

func (i *IPRateLimiter) AddIP(ip string) *rate.Limiter {
    i.mu.Lock()
    defer i.mu.Unlock()
    
    limiter := rate.NewLimiter(1, 100) // 1 request/second, burst 100
    i.ips[ip] = limiter
    
    return limiter
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
    i.mu.RLock()
    limiter, exists := i.ips[ip]
    i.mu.RUnlock()
    
    if !exists {
        return i.AddIP(ip)
    }
    
    return limiter
}

func RateLimitMiddleware(securityConfig *SecurityConfig, requestsPerMinute int) gin.HandlerFunc {
    rateLimiter := NewIPRateLimiter(rate.Every(time.Minute), requestsPerMinute)
    
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // ç™½åå•IPä¸é™æµ
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        limiter := rateLimiter.GetLimiter(clientIP)
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•",
                "limit": requestsPerMinute,
                "window": "æ¯åˆ†é’Ÿ",
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

3. è¯·æ±‚å¹‚ç­‰å­˜å‚¨æ–¹æ¡ˆ
åŒæ„ï¼šåˆ›å»ºprocessed_requestsè¡¨ï¼Œ72å°æ—¶TTLæ¸…ç†
-- migrations/001_initial.sql
CREATE TABLE IF NOT EXISTS processed_requests (
    serial VARCHAR(50) NOT NULL,
    request_id VARCHAR(64) NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (serial, request_id)
);

CREATE INDEX IF NOT EXISTS idx_processed_requests_created_at ON processed_requests(created_at);

-- æ¸…ç†è¿‡æœŸè®°å½•çš„è§¦å‘å™¨ï¼ˆ72å°æ—¶ï¼‰
CREATE TRIGGER IF NOT EXISTS cleanup_processed_requests
AFTER INSERT ON processed_requests
BEGIN
    DELETE FROM processed_requests WHERE created_at < datetime('now', '-72 hours');
END;


4. å®¡è®¡æ—¥å¿—è½ç›˜å®ç°
åŒæ„ï¼šEnableAudit=trueæ—¶å†™å…¥æŒ‡å®šæ–‡ä»¶
// audit/logger.go
package audit

import (
    "encoding/json"
    "os"
    "sync"
    "time"
)

type AuditLogger struct {
    file   *os.File
    mu     sync.Mutex
    enable bool
}

func NewAuditLogger(logPath string, enable bool) (*AuditLogger, error) {
    if !enable {
        return &AuditLogger{enable: false}, nil
    }
    
    file, err := os.OpenFile(logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }
    
    return &AuditLogger{
        file:   file,
        enable: enable,
    }, nil
}

func (a *AuditLogger) LogEvent(event AuditLog) error {
    if !a.enable {
        return nil
    }
    
    a.mu.Lock()
    defer a.mu.Unlock()
    
    event.Timestamp = time.Now().Format(time.RFC3339)
    logJSON, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    _, err = a.file.Write(append(logJSON, '\n'))
    return err
}

func (a *AuditLogger) Close() error {
    if a.file != nil {
        return a.file.Close()
    }
    return nil
}


ğŸ”§ ä¸€è‡´æ€§æ£€æŸ¥å®æ–½
1. CIDRç™½åå•æ”¯æŒ
// utils/network.go
package utils

import (
    "net"
    "strings"
)

func IsIPInWhitelist(ip string, whitelist []string) bool {
    clientIP := net.ParseIP(ip)
    if clientIP == nil {
        return false
    }
    
    for _, item := range whitelist {
        if strings.Contains(item, "/") {
            // CIDRæ ¼å¼
            _, cidrNet, err := net.ParseCIDR(item)
            if err == nil && cidrNet.Contains(clientIP) {
                return true
            }
        } else {
            // å•IPæ ¼å¼
            if item == ip {
                return true
            }
        }
    }
    
    return false
}

2. Agentå‡½æ•°å®ç°ï¼ˆé™çº§å…¼å®¹ï¼‰
#!/bin/bash

# å¯ç§»æ¤çš„Agentè¾…åŠ©å‡½æ•°
detect_os_version() {
    if [ -f /etc/redhat-release ]; then
        cat /etc/redhat-release
    elif [ -f /etc/os-release ]; then
        . /etc/os-release
        echo "$PRETTY_NAME"
    else
        echo "unknown"
    fi
}

detect_memory_slots() {
    if [ "$CAN_USE_DMIDECODE" = true ] && command -v dmidecode >/dev/null; then
        dmidecode -t memory 2>/dev/null | grep -c "Size:.*MB" || echo 1
    else
        # é™çº§ï¼šé€šè¿‡ç‰©ç†å†…å­˜å¤§å°ä¼°ç®—
        mem_total_kb=$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || echo 0)
        if [ "$mem_total_kb" -gt 32000000 ]; then
            echo 4
        elif [ "$mem_total_kb" -gt 16000000 ]; then
            echo 2
        else
            echo 1
        fi
    fi
}

detect_nic_speed() {
    local nic=$1
    if [ -z "$nic" ]; then
        echo "unknown"
        return
    fi
    
    # æ–¹æ³•1: ethtool
    if command -v ethtool >/dev/null 2>&1; then
        speed=$(ethtool "$nic" 2>/dev/null | grep Speed | awk '{print $2}')
        if [ -n "$speed" ]; then
            echo "$speed"
            return
        fi
    fi
    
    # æ–¹æ³•2: é€šè¿‡/sysæ–‡ä»¶ç³»ç»Ÿ
    if [ -f "/sys/class/net/$nic/speed" ]; then
        speed=$(cat "/sys/class/net/$nic/speed" 2>/dev/null)
        if [ -n "$speed" ] && [ "$speed" -gt 0 ]; then
            echo "${speed}Mbps"
            return
        fi
    fi
    
    echo "unknown"
}

send_with_retry() {
    local json_data=$1
    local max_retries=3
    local retry_delay=5
    
    for i in $(seq 1 $max_retries); do
        if curl -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -d "$json_data" \
            --connect-timeout 10 \
            --max-time 30 \
            "$SERVER_URL" > /dev/null 2>&1; then
            echo "æ•°æ®ä¸ŠæŠ¥æˆåŠŸ"
            return 0
        fi
        
        if [ $i -lt $max_retries ]; then
            echo "ç¬¬ $i æ¬¡ä¸ŠæŠ¥å¤±è´¥ï¼Œ${retry_delay}ç§’åé‡è¯•..."
            sleep $retry_delay
        fi
    done
    
    echo "æ•°æ®ä¸ŠæŠ¥å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°"
    return 1
}

3. UEFIè·¯å¾„è‡ªå®šä¹‰æ”¯æŒ
// pxe/generator.go
type PXEConfig struct {
    EnableUEFI      bool   `json:"enableUEFI"`
    UEFIBootPath    string `json:"uefiBootPath"`    // æ”¯æŒè‡ªå®šä¹‰è·¯å¾„
    LegacyBootPath  string `json:"legacyBootPath"`  // æ”¯æŒè‡ªå®šä¹‰è·¯å¾„
    UEFIBootFile    string `json:"uefiBootFile"`
    UEFIConfigFile  string `json:"uefiConfigFile"`
    LegacyBootFile  string `json:"legacyBootFile"`
}

func (g *Generator) GenerateUEFIConfig(mac string, server *Server, template *ConfigTemplate) error {
    // æ”¯æŒè‡ªå®šä¹‰UEFIè·¯å¾„
    uefiConfigPath := filepath.Join(g.TFTPRoot, g.PXEConfig.UEFIBootPath, g.PXEConfig.UEFIConfigFile)
    
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(filepath.Dir(uefiConfigPath), 0755); err != nil {
        return fmt.Errorf("åˆ›å»ºUEFIé…ç½®ç›®å½•å¤±è´¥: %w", err)
    }
    
    configContent := g.RenderUEFIConfig(server, template)
    return os.WriteFile(uefiConfigPath, []byte(configContent), 0644)
}


ğŸš€ ç«‹å³æ‰§è¡Œé¡¹ç›®æˆæƒ
åŸºäºæ‚¨çš„ç¡®è®¤ï¼Œæˆ‘è·å¾—æˆæƒç«‹å³å®æ–½ä»¥ä¸‹é¡¹ç›®ï¼š

1. åˆ›å»ºæ•°æ®åº“è¿ç§»è„šæœ¬
migrations/001_initial.sql - å«ä¼˜åŒ–çš„è§¦å‘å™¨ã€ç´¢å¼•å’Œprocessed_requestsè¡¨

2. å®ç°æ•°æ®åº“è¿æ¥å±‚
database/db.go - SQLite WAL + busy_timeout + å¤–é”®å¯ç”¨

database/init.go - æ•°æ®åº“åˆå§‹åŒ–å’Œè¿ç§»æ‰§è¡Œ

3. å®šä¹‰ç»Ÿä¸€æ•°æ®æ¨¡å‹
database/models.go - API camelCaseä¸DB snake_caseæ˜ å°„

database/repository.go - æ•°æ®è®¿é—®å±‚

4. åˆ›å»ºè®¤è¯å’Œé™æµä¸­é—´ä»¶
auth/middleware.go - ç»Ÿä¸€ç™½åå•ä¸Bearerè®¤è¯

auth/ratelimit.go - æŒ‰IPç»´åº¦é™æµï¼Œç™½åå•è±å…

auth/security.go - å®‰å…¨é…ç½®ç»“æ„

5. è¾…åŠ©å·¥å…·æ¨¡å—
utils/network.go - CIDRç™½åå•æ”¯æŒ
audit/logger.go - å®¡è®¡æ—¥å¿—æ–‡ä»¶è½ç›˜
