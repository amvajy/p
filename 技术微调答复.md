✅ 技术微调确认
1. SQLite触发器语法修正
同意：使用列集限定的AFTER UPDATE触发器
-- migrations/001_initial.sql
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp
AFTER UPDATE OF serial, hostname, ip_address, mac_address, gateway, install_time, 
                  sda_size, part, system_version, kernel_version, cpu_model, 
                  cpu_processor, mem_total, memory_num, lan_nic, lan_nic_speed, 
                  wan_nic, wan_nic_speed, bond_nic, bond_nic_speed, status 
ON servers
FOR EACH ROW
BEGIN
    UPDATE servers SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;



2. 限流器维度优化
同意：按IP维度维护独立限流器，使用带TTL的本地缓存
// auth/ratelimit.go
package auth

import (
    "net/http"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
    "github.com/gin-gonic/gin"
)

type IPRateLimiter struct {
    ips map[string]*rate.Limiter
    mu   *sync.RWMutex
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
    return &IPRateLimiter{
        ips: make(map[string]*rate.Limiter),
        mu:   &sync.RWMutex{},
    }
}

func (i *IPRateLimiter) AddIP(ip string) *rate.Limiter {
    i.mu.Lock()
    defer i.mu.Unlock()
    
    limiter := rate.NewLimiter(1, 100) // 1 request/second, burst 100
    i.ips[ip] = limiter
    
    return limiter
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
    i.mu.RLock()
    limiter, exists := i.ips[ip]
    i.mu.RUnlock()
    
    if !exists {
        return i.AddIP(ip)
    }
    
    return limiter
}

func RateLimitMiddleware(securityConfig *SecurityConfig, requestsPerMinute int) gin.HandlerFunc {
    rateLimiter := NewIPRateLimiter(rate.Every(time.Minute), requestsPerMinute)
    
    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        
        // 白名单IP不限流
        if isIPInWhitelist(clientIP, securityConfig.WhitelistIPs) {
            c.Next()
            return
        }
        
        limiter := rateLimiter.GetLimiter(clientIP)
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "请求过于频繁，请稍后重试",
                "limit": requestsPerMinute,
                "window": "每分钟",
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

3. 请求幂等存储方案
同意：创建processed_requests表，72小时TTL清理
-- migrations/001_initial.sql
CREATE TABLE IF NOT EXISTS processed_requests (
    serial VARCHAR(50) NOT NULL,
    request_id VARCHAR(64) NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (serial, request_id)
);

CREATE INDEX IF NOT EXISTS idx_processed_requests_created_at ON processed_requests(created_at);

-- 清理过期记录的触发器（72小时）
CREATE TRIGGER IF NOT EXISTS cleanup_processed_requests
AFTER INSERT ON processed_requests
BEGIN
    DELETE FROM processed_requests WHERE created_at < datetime('now', '-72 hours');
END;


4. 审计日志落盘实现
同意：EnableAudit=true时写入指定文件
// audit/logger.go
package audit

import (
    "encoding/json"
    "os"
    "sync"
    "time"
)

type AuditLogger struct {
    file   *os.File
    mu     sync.Mutex
    enable bool
}

func NewAuditLogger(logPath string, enable bool) (*AuditLogger, error) {
    if !enable {
        return &AuditLogger{enable: false}, nil
    }
    
    file, err := os.OpenFile(logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }
    
    return &AuditLogger{
        file:   file,
        enable: enable,
    }, nil
}

func (a *AuditLogger) LogEvent(event AuditLog) error {
    if !a.enable {
        return nil
    }
    
    a.mu.Lock()
    defer a.mu.Unlock()
    
    event.Timestamp = time.Now().Format(time.RFC3339)
    logJSON, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    _, err = a.file.Write(append(logJSON, '\n'))
    return err
}

func (a *AuditLogger) Close() error {
    if a.file != nil {
        return a.file.Close()
    }
    return nil
}


🔧 一致性检查实施
1. CIDR白名单支持
// utils/network.go
package utils

import (
    "net"
    "strings"
)

func IsIPInWhitelist(ip string, whitelist []string) bool {
    clientIP := net.ParseIP(ip)
    if clientIP == nil {
        return false
    }
    
    for _, item := range whitelist {
        if strings.Contains(item, "/") {
            // CIDR格式
            _, cidrNet, err := net.ParseCIDR(item)
            if err == nil && cidrNet.Contains(clientIP) {
                return true
            }
        } else {
            // 单IP格式
            if item == ip {
                return true
            }
        }
    }
    
    return false
}

2. Agent函数实现（降级兼容）
#!/bin/bash

# 可移植的Agent辅助函数
detect_os_version() {
    if [ -f /etc/redhat-release ]; then
        cat /etc/redhat-release
    elif [ -f /etc/os-release ]; then
        . /etc/os-release
        echo "$PRETTY_NAME"
    else
        echo "unknown"
    fi
}

detect_memory_slots() {
    if [ "$CAN_USE_DMIDECODE" = true ] && command -v dmidecode >/dev/null; then
        dmidecode -t memory 2>/dev/null | grep -c "Size:.*MB" || echo 1
    else
        # 降级：通过物理内存大小估算
        mem_total_kb=$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || echo 0)
        if [ "$mem_total_kb" -gt 32000000 ]; then
            echo 4
        elif [ "$mem_total_kb" -gt 16000000 ]; then
            echo 2
        else
            echo 1
        fi
    fi
}

detect_nic_speed() {
    local nic=$1
    if [ -z "$nic" ]; then
        echo "unknown"
        return
    fi
    
    # 方法1: ethtool
    if command -v ethtool >/dev/null 2>&1; then
        speed=$(ethtool "$nic" 2>/dev/null | grep Speed | awk '{print $2}')
        if [ -n "$speed" ]; then
            echo "$speed"
            return
        fi
    fi
    
    # 方法2: 通过/sys文件系统
    if [ -f "/sys/class/net/$nic/speed" ]; then
        speed=$(cat "/sys/class/net/$nic/speed" 2>/dev/null)
        if [ -n "$speed" ] && [ "$speed" -gt 0 ]; then
            echo "${speed}Mbps"
            return
        fi
    fi
    
    echo "unknown"
}

send_with_retry() {
    local json_data=$1
    local max_retries=3
    local retry_delay=5
    
    for i in $(seq 1 $max_retries); do
        if curl -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -d "$json_data" \
            --connect-timeout 10 \
            --max-time 30 \
            "$SERVER_URL" > /dev/null 2>&1; then
            echo "数据上报成功"
            return 0
        fi
        
        if [ $i -lt $max_retries ]; then
            echo "第 $i 次上报失败，${retry_delay}秒后重试..."
            sleep $retry_delay
        fi
    done
    
    echo "数据上报失败，已达最大重试次数"
    return 1
}

3. UEFI路径自定义支持
// pxe/generator.go
type PXEConfig struct {
    EnableUEFI      bool   `json:"enableUEFI"`
    UEFIBootPath    string `json:"uefiBootPath"`    // 支持自定义路径
    LegacyBootPath  string `json:"legacyBootPath"`  // 支持自定义路径
    UEFIBootFile    string `json:"uefiBootFile"`
    UEFIConfigFile  string `json:"uefiConfigFile"`
    LegacyBootFile  string `json:"legacyBootFile"`
}

func (g *Generator) GenerateUEFIConfig(mac string, server *Server, template *ConfigTemplate) error {
    // 支持自定义UEFI路径
    uefiConfigPath := filepath.Join(g.TFTPRoot, g.PXEConfig.UEFIBootPath, g.PXEConfig.UEFIConfigFile)
    
    // 确保目录存在
    if err := os.MkdirAll(filepath.Dir(uefiConfigPath), 0755); err != nil {
        return fmt.Errorf("创建UEFI配置目录失败: %w", err)
    }
    
    configContent := g.RenderUEFIConfig(server, template)
    return os.WriteFile(uefiConfigPath, []byte(configContent), 0644)
}


🚀 立即执行项目授权
基于您的确认，我获得授权立即实施以下项目：

1. 创建数据库迁移脚本
migrations/001_initial.sql - 含优化的触发器、索引和processed_requests表

2. 实现数据库连接层
database/db.go - SQLite WAL + busy_timeout + 外键启用

database/init.go - 数据库初始化和迁移执行

3. 定义统一数据模型
database/models.go - API camelCase与DB snake_case映射

database/repository.go - 数据访问层

4. 创建认证和限流中间件
auth/middleware.go - 统一白名单与Bearer认证

auth/ratelimit.go - 按IP维度限流，白名单豁免

auth/security.go - 安全配置结构

5. 辅助工具模块
utils/network.go - CIDR白名单支持
audit/logger.go - 审计日志文件落盘
