✅ 细节补充确认
1. 速率限制口径
同意：按每分钟请求数定义，默认100请求/分钟/IP
type RateLimitConfig struct {
    RequestsPerMinute int      `json:"requests_per_minute"` // 默认100
    WhitelistIPs      []string `json:"whitelist_ips"`       // IP白名单
    Enable            bool     `json:"enable"`              // 是否启用
}

2. SQLite稳健性优化
同意：启用WAL模式和busy_timeout
func InitSQLite(dbPath string) (*sql.DB, error) {
    db, err := sql.Open("sqlite3", dbPath+"?_journal_mode=WAL&_timeout=5000")
    if err != nil {
        return nil, err
    }
    
    // 设置连接池和WAL参数
    db.SetMaxOpenConns(1) // SQLite写并发限制
    db.SetMaxIdleConns(1)
    
    return db, nil
}

3. UEFI支持实现
同意：区分Legacy BIOS和UEFI引导
type PXEConfig struct {
    EnableUEFI      bool   `json:"enable_uefi"`
    UEFIBootPath    string `json:"uefi_boot_path"`    // efi/boot/
    LegacyBootPath  string `json:"legacy_boot_path"`  // pxelinux.cfg/
    GrubConfig      string `json:"grub_config"`       // UEFI grub.cfg模板
    SyslinuxConfig  string `json:"syslinux_config"`   // Legacy配置模板
}

func GenerateBootConfig(mac string, config *ConfigTemplate, pxeConfig *PXEConfig) error {
    if pxeConfig.EnableUEFI {
        return generateUEFIConfig(mac, config, pxeConfig)
    }
    return generateLegacyConfig(mac, config, pxeConfig)
}


4. 安全与运维增强
同意：AuthToken从环境变量加载，增加审计日志
type SecurityConfig struct {
    AuthToken    string   `json:"-"`                    // 从环境变量加载，不序列化到配置文件
    IPWhitelist  []string `json:"ip_whitelist"`
    EnableAudit  bool     `json:"enable_audit"`
    AuditLogPath string   `json:"audit_log_path"`
}

func LoadAuthToken() string {
    if token := os.Getenv("PXE_AUTH_TOKEN"); token != "" {
        return token
    }
    // 回退到配置文件（仅开发环境）
    return config.AuthToken
}


5. Windows兼容性
同意：Windows构建主要供开发/编译使用，TFTP相关功能在Windows下可选启用
func EnsureTFTPDir(tftpRoot string) error {
    if runtime.GOOS == "windows" {
        // Windows环境检查，可选启用TFTP
        log.Warn("TFTP功能在Windows下受限，建议在Linux环境部署")
        return nil
    }
    return os.MkdirAll(tftpRoot, 0755)
}



🚨 风险缓解措施
1. 离线环境依赖处理
// Agent采集策略
type CollectionStrategy struct {
    UseDMIdecode    bool `json:"use_dmidecode"`    // 有root权限时使用
    UseIPCommand    bool `json:"use_ip_command"`   // 优先使用ip命令
    UseFallbackAPI  bool `json:"use_fallback_api"` // 使用/proc、/sys等文件系统
    TimeoutSeconds  int  `json:"timeout_seconds"`  // 单次采集超时
}

// 网卡名称自适应
func DetectNetworkInterfaces() ([]NetworkInterface, error) {
    // 方法1: 通过/sys/class/net遍历
    // 方法2: 通过ip link show
    // 方法3: 通过net.Interfaces()
    // 返回标准化网卡信息
}

2. 模板渲染一致性保障
type TemplateData struct {
    Server *Server
    Config *ConfigTemplate
    Network struct {
        IP       string
        Netmask  string
        Gateway  string
        Hostname string
    }
}

// 模板预验证
func ValidateTemplate(templateContent string, data *TemplateData) error {
    // 检查所有必需的变量是否在数据中定义
    // 防止渲染时出现空指针或缺失字段
}


3. 文件命名标准化
func FormatMACForPXE(mac string) (string, error) {
    // 统一格式: 01-aa-bb-cc-dd-ee-ff
    cleaned := strings.ReplaceAll(strings.ToLower(mac), ":", "")
    if len(cleaned) != 12 {
        return "", fmt.Errorf("invalid MAC address: %s", mac)
    }
    
    formatted := "01-"
    for i := 0; i < 12; i += 2 {
        if i > 0 {
            formatted += "-"
        }
        formatted += cleaned[i:i+2]
    }
    return formatted, nil
}


🚀 下一步行动实施
第一阶段：立即执行（本周）
1. 路由与中间件骨架
// auth/middleware.go
package auth

import (
    "net/http"
    "strings"
    "github.com/gin-gonic/gin"
)

func Middleware(authToken string) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if !strings.HasPrefix(token, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "未提供认证令牌"})
            c.Abort()
            return
        }
        
        if strings.TrimPrefix(token, "Bearer ") != authToken {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的认证令牌"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

2. 数据层与迁移
-- migrations/001_initial.sql
CREATE TABLE IF NOT EXISTS servers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    serial VARCHAR(50) UNIQUE NOT NULL,
    hostname VARCHAR(100),
    ip_address VARCHAR(15),
    mac_address VARCHAR(17),
    gateway VARCHAR(15),
    install_time DATETIME,
    sda_size VARCHAR(20),
    part TEXT,
    system_version VARCHAR(100),
    kernel_version VARCHAR(100),
    cpu_model VARCHAR(100),
    cpu_processor INTEGER,
    mem_total INTEGER,
    memory_num INTEGER,
    lan_nic VARCHAR(50),
    lan_nic_speed VARCHAR(50),
    wan_nic VARCHAR(50),
    wan_nic_speed VARCHAR(50),
    bond_nic VARCHAR(50),
    bond_nic_speed VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_servers_serial ON servers(serial);
CREATE INDEX IF NOT EXISTS idx_servers_mac ON servers(mac_address);
CREATE INDEX IF NOT EXISTS idx_servers_status ON servers(status);

-- 更新触发器
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp 
AFTER UPDATE ON servers
BEGIN
    UPDATE servers SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;


3. 字段统一与序列化
// models.go - 统一小驼峰
type Server struct {
    ID            int    `json:"id" db:"id"`
    Serial        string `json:"serial" db:"serial"`
    Hostname      string `json:"hostname" db:"hostname"`
    IPAddress     string `json:"ipAddress" db:"ip_address"`
    MACAddress    string `json:"macAddress" db:"mac_address"`
    // ... 其他字段统一为小驼峰
}

// 更新Agent脚本中的JSON字段


第二阶段：核心功能（下周）
4. PXE生成引擎
// pxe/generator.go
package pxe

type Generator struct {
    TFTPRoot   string
    EnableUEFI bool
}

func (g *Generator) GenerateConfig(server *Server, template *ConfigTemplate) error {
    // 1. 格式化MAC地址
    pxeFileName, err := FormatMACForPXE(server.MACAddress)
    if err != nil {
        return err
    }
    
    // 2. 根据模板类型生成配置
    var configContent string
    switch template.SystemType {
    case "centos", "rhel":
        configContent = GenerateKickstart(server, template)
    case "ubuntu", "debian":
        configContent = GeneratePreseed(server, template)
    default:
        return fmt.Errorf("不支持的系统类型: %s", template.SystemType)
    }
    
    // 3. 写入TFTP目录
    configPath := filepath.Join(g.TFTPRoot, "pxelinux.cfg", pxeFileName)
    return os.WriteFile(configPath, []byte(configContent), 0644)
}

5. Web前端交互完善
// web/static/js/app.js - 完善saveConfig和applyConfig
async function saveConfig() {
    const configId = document.getElementById('configSelect').value;
    const content = document.getElementById('configContent').value;
    
    try {
        showLoading();
        const url = configId ? `/api/configs/${configId}` : '/api/configs';
        const method = configId ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ configContent: content })
        });
        
        if (!response.ok) throw new Error('保存失败');
        showSuccess('配置保存成功');
    } catch (error) {
        showError(error.message);
    } finally {
        hideLoading();
    }
}

async function applyConfig() {
    const configId = document.getElementById('configSelect').value;
    const serverSerial = document.getElementById('serverSelect').value;
    
    if (!configId || !serverSerial) {
        showError('请选择配置模板和目标服务器');
        return;
    }
    
    try {
        showLoading();
        const response = await fetch(`/api/configs/${configId}/apply?serial=${serverSerial}`, {
            method: 'POST'
        });
        
        if (!response.ok) throw new Error('应用配置失败');
        showSuccess('配置已应用到服务器');
    } catch (error) {
        showError(error.message);
    } finally {
        hideLoading();
    }
}


📋 交付物清单确认
migrations/001_initial.sql - 数据库迁移脚本
auth/middleware.go - 认证中间件
auth/ratelimit.go - 速率限制
database/db.go - 数据库初始化（SQLite WAL）
database/models.go - 统一字段模型
pxe/generator.go - PXE配置生成核心
pxe/kickstart.go - CentOS模板渲染
pxe/preseed.go - Ubuntu模板渲染
web/static/js/app.js - 完善的前端交互
更新的Agent脚本 - 小驼峰字段+网卡探测


