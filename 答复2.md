âœ… ç»†èŠ‚è¡¥å……ç¡®è®¤
1. é€Ÿç‡é™åˆ¶å£å¾„
åŒæ„ï¼šæŒ‰æ¯åˆ†é’Ÿè¯·æ±‚æ•°å®šä¹‰ï¼Œé»˜è®¤100è¯·æ±‚/åˆ†é’Ÿ/IP
type RateLimitConfig struct {
    RequestsPerMinute int      `json:"requests_per_minute"` // é»˜è®¤100
    WhitelistIPs      []string `json:"whitelist_ips"`       // IPç™½åå•
    Enable            bool     `json:"enable"`              // æ˜¯å¦å¯ç”¨
}

2. SQLiteç¨³å¥æ€§ä¼˜åŒ–
åŒæ„ï¼šå¯ç”¨WALæ¨¡å¼å’Œbusy_timeout
func InitSQLite(dbPath string) (*sql.DB, error) {
    db, err := sql.Open("sqlite3", dbPath+"?_journal_mode=WAL&_timeout=5000")
    if err != nil {
        return nil, err
    }
    
    // è®¾ç½®è¿æ¥æ± å’ŒWALå‚æ•°
    db.SetMaxOpenConns(1) // SQLiteå†™å¹¶å‘é™åˆ¶
    db.SetMaxIdleConns(1)
    
    return db, nil
}

3. UEFIæ”¯æŒå®ç°
åŒæ„ï¼šåŒºåˆ†Legacy BIOSå’ŒUEFIå¼•å¯¼
type PXEConfig struct {
    EnableUEFI      bool   `json:"enable_uefi"`
    UEFIBootPath    string `json:"uefi_boot_path"`    // efi/boot/
    LegacyBootPath  string `json:"legacy_boot_path"`  // pxelinux.cfg/
    GrubConfig      string `json:"grub_config"`       // UEFI grub.cfgæ¨¡æ¿
    SyslinuxConfig  string `json:"syslinux_config"`   // Legacyé…ç½®æ¨¡æ¿
}

func GenerateBootConfig(mac string, config *ConfigTemplate, pxeConfig *PXEConfig) error {
    if pxeConfig.EnableUEFI {
        return generateUEFIConfig(mac, config, pxeConfig)
    }
    return generateLegacyConfig(mac, config, pxeConfig)
}


4. å®‰å…¨ä¸è¿ç»´å¢å¼º
åŒæ„ï¼šAuthTokenä»ç¯å¢ƒå˜é‡åŠ è½½ï¼Œå¢åŠ å®¡è®¡æ—¥å¿—
type SecurityConfig struct {
    AuthToken    string   `json:"-"`                    // ä»ç¯å¢ƒå˜é‡åŠ è½½ï¼Œä¸åºåˆ—åŒ–åˆ°é…ç½®æ–‡ä»¶
    IPWhitelist  []string `json:"ip_whitelist"`
    EnableAudit  bool     `json:"enable_audit"`
    AuditLogPath string   `json:"audit_log_path"`
}

func LoadAuthToken() string {
    if token := os.Getenv("PXE_AUTH_TOKEN"); token != "" {
        return token
    }
    // å›é€€åˆ°é…ç½®æ–‡ä»¶ï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰
    return config.AuthToken
}


5. Windowså…¼å®¹æ€§
åŒæ„ï¼šWindowsæ„å»ºä¸»è¦ä¾›å¼€å‘/ç¼–è¯‘ä½¿ç”¨ï¼ŒTFTPç›¸å…³åŠŸèƒ½åœ¨Windowsä¸‹å¯é€‰å¯ç”¨
func EnsureTFTPDir(tftpRoot string) error {
    if runtime.GOOS == "windows" {
        // Windowsç¯å¢ƒæ£€æŸ¥ï¼Œå¯é€‰å¯ç”¨TFTP
        log.Warn("TFTPåŠŸèƒ½åœ¨Windowsä¸‹å—é™ï¼Œå»ºè®®åœ¨Linuxç¯å¢ƒéƒ¨ç½²")
        return nil
    }
    return os.MkdirAll(tftpRoot, 0755)
}



ğŸš¨ é£é™©ç¼“è§£æªæ–½
1. ç¦»çº¿ç¯å¢ƒä¾èµ–å¤„ç†
// Agenté‡‡é›†ç­–ç•¥
type CollectionStrategy struct {
    UseDMIdecode    bool `json:"use_dmidecode"`    // æœ‰rootæƒé™æ—¶ä½¿ç”¨
    UseIPCommand    bool `json:"use_ip_command"`   // ä¼˜å…ˆä½¿ç”¨ipå‘½ä»¤
    UseFallbackAPI  bool `json:"use_fallback_api"` // ä½¿ç”¨/procã€/sysç­‰æ–‡ä»¶ç³»ç»Ÿ
    TimeoutSeconds  int  `json:"timeout_seconds"`  // å•æ¬¡é‡‡é›†è¶…æ—¶
}

// ç½‘å¡åç§°è‡ªé€‚åº”
func DetectNetworkInterfaces() ([]NetworkInterface, error) {
    // æ–¹æ³•1: é€šè¿‡/sys/class/netéå†
    // æ–¹æ³•2: é€šè¿‡ip link show
    // æ–¹æ³•3: é€šè¿‡net.Interfaces()
    // è¿”å›æ ‡å‡†åŒ–ç½‘å¡ä¿¡æ¯
}

2. æ¨¡æ¿æ¸²æŸ“ä¸€è‡´æ€§ä¿éšœ
type TemplateData struct {
    Server *Server
    Config *ConfigTemplate
    Network struct {
        IP       string
        Netmask  string
        Gateway  string
        Hostname string
    }
}

// æ¨¡æ¿é¢„éªŒè¯
func ValidateTemplate(templateContent string, data *TemplateData) error {
    // æ£€æŸ¥æ‰€æœ‰å¿…éœ€çš„å˜é‡æ˜¯å¦åœ¨æ•°æ®ä¸­å®šä¹‰
    // é˜²æ­¢æ¸²æŸ“æ—¶å‡ºç°ç©ºæŒ‡é’ˆæˆ–ç¼ºå¤±å­—æ®µ
}


3. æ–‡ä»¶å‘½åæ ‡å‡†åŒ–
func FormatMACForPXE(mac string) (string, error) {
    // ç»Ÿä¸€æ ¼å¼: 01-aa-bb-cc-dd-ee-ff
    cleaned := strings.ReplaceAll(strings.ToLower(mac), ":", "")
    if len(cleaned) != 12 {
        return "", fmt.Errorf("invalid MAC address: %s", mac)
    }
    
    formatted := "01-"
    for i := 0; i < 12; i += 2 {
        if i > 0 {
            formatted += "-"
        }
        formatted += cleaned[i:i+2]
    }
    return formatted, nil
}


ğŸš€ ä¸‹ä¸€æ­¥è¡ŒåŠ¨å®æ–½
ç¬¬ä¸€é˜¶æ®µï¼šç«‹å³æ‰§è¡Œï¼ˆæœ¬å‘¨ï¼‰
1. è·¯ç”±ä¸ä¸­é—´ä»¶éª¨æ¶
// auth/middleware.go
package auth

import (
    "net/http"
    "strings"
    "github.com/gin-gonic/gin"
)

func Middleware(authToken string) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if !strings.HasPrefix(token, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æœªæä¾›è®¤è¯ä»¤ç‰Œ"})
            c.Abort()
            return
        }
        
        if strings.TrimPrefix(token, "Bearer ") != authToken {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

2. æ•°æ®å±‚ä¸è¿ç§»
-- migrations/001_initial.sql
CREATE TABLE IF NOT EXISTS servers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    serial VARCHAR(50) UNIQUE NOT NULL,
    hostname VARCHAR(100),
    ip_address VARCHAR(15),
    mac_address VARCHAR(17),
    gateway VARCHAR(15),
    install_time DATETIME,
    sda_size VARCHAR(20),
    part TEXT,
    system_version VARCHAR(100),
    kernel_version VARCHAR(100),
    cpu_model VARCHAR(100),
    cpu_processor INTEGER,
    mem_total INTEGER,
    memory_num INTEGER,
    lan_nic VARCHAR(50),
    lan_nic_speed VARCHAR(50),
    wan_nic VARCHAR(50),
    wan_nic_speed VARCHAR(50),
    bond_nic VARCHAR(50),
    bond_nic_speed VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_servers_serial ON servers(serial);
CREATE INDEX IF NOT EXISTS idx_servers_mac ON servers(mac_address);
CREATE INDEX IF NOT EXISTS idx_servers_status ON servers(status);

-- æ›´æ–°è§¦å‘å™¨
CREATE TRIGGER IF NOT EXISTS update_servers_timestamp 
AFTER UPDATE ON servers
BEGIN
    UPDATE servers SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;


3. å­—æ®µç»Ÿä¸€ä¸åºåˆ—åŒ–
// models.go - ç»Ÿä¸€å°é©¼å³°
type Server struct {
    ID            int    `json:"id" db:"id"`
    Serial        string `json:"serial" db:"serial"`
    Hostname      string `json:"hostname" db:"hostname"`
    IPAddress     string `json:"ipAddress" db:"ip_address"`
    MACAddress    string `json:"macAddress" db:"mac_address"`
    // ... å…¶ä»–å­—æ®µç»Ÿä¸€ä¸ºå°é©¼å³°
}

// æ›´æ–°Agentè„šæœ¬ä¸­çš„JSONå­—æ®µ


ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½ï¼ˆä¸‹å‘¨ï¼‰
4. PXEç”Ÿæˆå¼•æ“
// pxe/generator.go
package pxe

type Generator struct {
    TFTPRoot   string
    EnableUEFI bool
}

func (g *Generator) GenerateConfig(server *Server, template *ConfigTemplate) error {
    // 1. æ ¼å¼åŒ–MACåœ°å€
    pxeFileName, err := FormatMACForPXE(server.MACAddress)
    if err != nil {
        return err
    }
    
    // 2. æ ¹æ®æ¨¡æ¿ç±»å‹ç”Ÿæˆé…ç½®
    var configContent string
    switch template.SystemType {
    case "centos", "rhel":
        configContent = GenerateKickstart(server, template)
    case "ubuntu", "debian":
        configContent = GeneratePreseed(server, template)
    default:
        return fmt.Errorf("ä¸æ”¯æŒçš„ç³»ç»Ÿç±»å‹: %s", template.SystemType)
    }
    
    // 3. å†™å…¥TFTPç›®å½•
    configPath := filepath.Join(g.TFTPRoot, "pxelinux.cfg", pxeFileName)
    return os.WriteFile(configPath, []byte(configContent), 0644)
}

5. Webå‰ç«¯äº¤äº’å®Œå–„
// web/static/js/app.js - å®Œå–„saveConfigå’ŒapplyConfig
async function saveConfig() {
    const configId = document.getElementById('configSelect').value;
    const content = document.getElementById('configContent').value;
    
    try {
        showLoading();
        const url = configId ? `/api/configs/${configId}` : '/api/configs';
        const method = configId ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ configContent: content })
        });
        
        if (!response.ok) throw new Error('ä¿å­˜å¤±è´¥');
        showSuccess('é…ç½®ä¿å­˜æˆåŠŸ');
    } catch (error) {
        showError(error.message);
    } finally {
        hideLoading();
    }
}

async function applyConfig() {
    const configId = document.getElementById('configSelect').value;
    const serverSerial = document.getElementById('serverSelect').value;
    
    if (!configId || !serverSerial) {
        showError('è¯·é€‰æ‹©é…ç½®æ¨¡æ¿å’Œç›®æ ‡æœåŠ¡å™¨');
        return;
    }
    
    try {
        showLoading();
        const response = await fetch(`/api/configs/${configId}/apply?serial=${serverSerial}`, {
            method: 'POST'
        });
        
        if (!response.ok) throw new Error('åº”ç”¨é…ç½®å¤±è´¥');
        showSuccess('é…ç½®å·²åº”ç”¨åˆ°æœåŠ¡å™¨');
    } catch (error) {
        showError(error.message);
    } finally {
        hideLoading();
    }
}


ğŸ“‹ äº¤ä»˜ç‰©æ¸…å•ç¡®è®¤
migrations/001_initial.sql - æ•°æ®åº“è¿ç§»è„šæœ¬
auth/middleware.go - è®¤è¯ä¸­é—´ä»¶
auth/ratelimit.go - é€Ÿç‡é™åˆ¶
database/db.go - æ•°æ®åº“åˆå§‹åŒ–ï¼ˆSQLite WALï¼‰
database/models.go - ç»Ÿä¸€å­—æ®µæ¨¡å‹
pxe/generator.go - PXEé…ç½®ç”Ÿæˆæ ¸å¿ƒ
pxe/kickstart.go - CentOSæ¨¡æ¿æ¸²æŸ“
pxe/preseed.go - Ubuntuæ¨¡æ¿æ¸²æŸ“
web/static/js/app.js - å®Œå–„çš„å‰ç«¯äº¤äº’
æ›´æ–°çš„Agentè„šæœ¬ - å°é©¼å³°å­—æ®µ+ç½‘å¡æ¢æµ‹


